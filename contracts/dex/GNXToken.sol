// SPDX-License-Identifier: MITpragma solidity ^0.8.7;// Token protocolsimport {IERC20Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";import {ERC20Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";import {IERC1363Upgradeable} from "@openzeppelin/contracts-upgradeable/interfaces/IERC1363Upgradeable.sol";import {ERC1363Upgradeable} from "./tokens/ERC1363Upgradeable.sol";// Peripheral protocolsimport {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";import {ContextUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol";// Access controlimport {AccessControlUpgradeable} from "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";// Proxy Upgradesimport {UUPSUpgradeable} from "@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol";// Interface detectionimport {IERC165Upgradeable} from "@openzeppelin/contracts-upgradeable/interfaces/IERC165Upgradeable.sol";import {ERC165Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol";interface IGNXToken is IERC20Upgradeable {    // Mints new GNX Tokens    function mint(address _address, uint256 _amount) external returns (bool);    // Burns existing GNX Tokens    function burn(address _address, uint256 _amount) external returns (bool);    // Issuer's address    function issuer() external view returns (address);        // Dividend's system    function depositDividend() external payable returns (uint256);    function withdrawDividend(address _recipient) external returns (uint256);    function withdrawableDividendOf(address _address) external returns (uint256);        event dividendDeposited(address indexed from, uint256 amount);    event dividendWithdrawn(address indexed from, address indexed to, uint256 amount);}// @title Upgradeable ERC1363 (extender ERC20) base GNX wrapper token with dividend functionality//// @notice Upgradeable ERC1363 with AccessControl using Open Zeppelin's implementation// Inheritance must follow this path for C3 solidity linearizationcontract GNXToken is    Initializable,    ContextUpgradeable,    ERC165Upgradeable,    AccessControlUpgradeable,    ERC1363Upgradeable,    UUPSUpgradeable,    IGNXToken {        // !NOTE : Maybe convert these to functions and label these as private?    // They need to be public?    /// Issuer's role    bytes32 public constant ROLE_ISSUER = keccak256("ISSUER");    /// Minter role    bytes32 public constant ROLE_MINTER = keccak256("MINTER");    // Issuer's address    address public override(IGNXToken) issuer;    function initialize(        string memory _name,        string memory _symbol,        uint256 _initialSupply,        address _issuer,        address _minter,        address _admin    ) public initializer {        // init funtions        __Context_init_unchained();        __ERC165_init_unchained();        __ERC20_init_unchained(_name, _symbol);        __AccessControl_init_unchained();        // set vars and roles        issuer = _issuer;                           // sets public issuer address        _setupRole(DEFAULT_ADMIN_ROLE, _admin);     // sets the admin role        _setupRole(ROLE_ISSUER, _issuer);           // sets the issuer role        _setupRole(ROLE_MINTER, _minter);           // sets the minter role        _setRoleAdmin(ROLE_ISSUER, ROLE_ISSUER);    // sets the admin of ROLE_ISSUER to                                                     // ROLE_ISSUER, making them their                                                    // own admin.        _mint(_issuer, _initialSupply);             // mints initial supply    }        /// @inheritdoc ERC165Upgradeable    function supportsInterface(bytes4 interfaceId)        public        view        override(ERC165Upgradeable, AccessControlUpgradeable, ERC1363Upgradeable)        returns (bool)    {        return            interfaceId == type(IERC20Upgradeable).interfaceId ||            interfaceId == type(IERC1363Upgradeable).interfaceId ||            super.supportsInterface(interfaceId);    }    // UUPS compliant by adding access control (onlyRole)    //     // @notice Refer to ERC1967Proxy, UUPSUpgradeable, TransparentUpgradeableProxy.    //     // @notice Inherit UUPSUpgradeable and add access control to create UUPS compliant    //         implementation. TransparentUpgradeableProxy and UUPS implementation    //         cannot be used together.    //    // @param newImplementation New implementation contract address    function _authorizeUpgrade(address newImplementation)        internal        override(UUPSUpgradeable)        onlyRole(DEFAULT_ADMIN_ROLE) {    }    // Mints new GNXTokens to recipient    //    // @notice Only accessible to ROLE_MINTER    //    // @param _recipient Recipient of the new tokens    // @param _amount Quantity minted    // @return Bool whether or not mint was succesful or failed.    function mint(address _recipient, uint256 _amount) public override(IGNXToken) onlyRole(ROLE_MINTER) returns (bool) {        _mint(_recipient, _amount);        return true;    }    /// Burns existing GNXTokens from address    ///    /// @notice Only accessible to ROLE_MINTER    ///    /// @param _from Address to burn tokens from    /// @param _amount Quantity burned    function burn(address _from, uint256 _amount) public override(IGNXToken) onlyRole(ROLE_MINTER) returns (bool) {        _burn(_from, _amount);        return true;    }    /// Change issuer address    ///    /// @notice Callable by the issuer to chance his own ownership address    ///    /// @notice onlyRole() is not needed here, since the equivalent check is    /// already done by `grantRole`, which only allows the role's admin, which    /// is the ISSUER_ROLE itself, to grant the role.    ///    /// @param _newIssuer New address of the issuer    function changeIssuerWallet(address _newIssuer) public {        issuer = _newIssuer;        grantRole(ROLE_ISSUER, _newIssuer);        revokeRole(ROLE_ISSUER, msg.sender);    }        /////////////////    //  DIVIDENDS  //    /////////////////        // Maps withdrawn dividends to token holders;    mapping(address => uint256) internal withdrawnDividends;        // Deposit dividend    //    // Dividends need to be withdrawn in portion to totalSupply    function depositDividend() public payable override onlyRole(ROLE_ISSUER) returns (uint256) {        require(msg.value > 0, "GNX: cannot deposit 0");        emit dividendDeposited(msg.sender, msg.value);        return msg.value;    }        // Withdraw occurs in proportion to total ether amount held in contract    // Current risk is multi-withdraw: if a msg.sender withdraws, the "withdraw points" are added    // to their account. They then send their tokens to another acount with no "withdraw points,"    // and they can redeem the same amount from that account. Repeat until the pool is empty of     // redeemable dividends.    // Possible solution --> Burn the token    // Second solution --> prevent transfer for 4 days    // Third solution --> replace token with a different token temporarily        function withdrawDividend(address _recipient) public override returns (uint256) {        require(address(this).balance > 0, "GNX: no dividends available"); // contract must have value        require(balanceOf(msg.sender) > 0, "GNX: no tokens"); // sender must have some tokens        // Check if user has already withdrawn max amount        uint256 withdrawableDividend = withdrawableDividendOf(msg.sender);        require(withdrawableDividend > 0,"GNX: already withdrawn");        // Send dividend and update withdrawn amount        withdrawnDividends[msg.sender] += withdrawableDividend; // update amount withdrawn        payable(_recipient).transfer(withdrawableDividend); // sends amount                emit dividendWithdrawn(msg.sender, _recipient, withdrawableDividend);                return withdrawableDividend;    }        function withdrawableDividendOf(address _address) public view override returns (uint256) {        require(address(this).balance > 0, "GNX: no dividends available"); // unecessary?        require(balanceOf(_address) > 0, "GNX: no tokens"); // unecessary?        uint256 dividend = (address(this).balance * balanceOf(_address)) / totalSupply();        uint256 withdrawableDividend = dividend - withdrawnDividends[_address];                return withdrawableDividend;    }        // allows a token holder to lock accrued dividends to sell token --> IMPLEMENT    // function lockDividends()        // undistributed dividends to see how much locked in the contract    // function totalDividends()    }